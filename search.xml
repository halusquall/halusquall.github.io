<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[C++队列缓存的实现]]></title>
      <url>halueyes.github.io/2016/04/20/C++%E9%98%9F%E5%88%97%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="C-队列缓存的实现"><a href="#C-队列缓存的实现" class="headerlink" title="C++队列缓存的实现"></a>C++队列缓存的实现</h1><p>##为什么使用队列缓存<br>c++的队列缓存主要用于解决大数据量并发时的数据存储问题，可以将并发时的数据缓存到队列中，当数据量变小时再匀速写入硬盘中。</p>
<p>##引用queue队列<br>在头文件中引用queue队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure></p>
<p>##定义缓存结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct DataInfo</span><br><span class="line">&#123;</span><br><span class="line">	char* pBuf;//缓存内容</span><br><span class="line">	int iSize;//缓存大小</span><br><span class="line"></span><br><span class="line">	DataInfo()</span><br><span class="line">	&#123;</span><br><span class="line">		pBuf = NULL;</span><br><span class="line">		iSize = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>##实例化queue队列<br>在头文件中实例化缓存队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;DataInfo&gt; m_dq_buf;		// 缓存队列</span><br></pre></td></tr></table></figure></p>
<p>##创建管理缓存队列的临界区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION m_lock;</span><br><span class="line">InitializeCriticalSection(&amp;m_lock);<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<p>##缓存数据</p>
<p>在数据回调函数或采集线程中进行数据缓存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallBack</span><span class="params">(<span class="keyword">int</span> iType, <span class="keyword">char</span> *pData, <span class="keyword">int</span> len, <span class="keyword">void</span>* pClass )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    CMyClass * pThis = (CMyClass*)pClass;</span><br><span class="line">    DataInfo dataInfo;<span class="comment">//实例化缓存结构体</span></span><br><span class="line">    <span class="keyword">char</span>* pBuf = new <span class="keyword">char</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>];<span class="comment">//分配2M的缓存空间</span></span><br><span class="line">    <span class="comment">//缓存推送到队列</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pBuf, pdata, len);<span class="comment">//数据拷贝到缓存中</span></span><br><span class="line">    dataInfo.pBuf = pBuf;</span><br><span class="line">    dataInfo.iSize = pThis-&gt;_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用临界区加锁</span></span><br><span class="line">    EnterCriticalSection(&amp;pThis-&gt;m_lock);<span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">    pThis-&gt;m_dq_buf.push(dataInfo);<span class="comment">//数据缓存推送到队列里</span></span><br><span class="line"></span><br><span class="line">    LeaveCriticalSection(&amp;pThis-&gt;m_lock);<span class="comment">//退出临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##数据处理</p>
<blockquote>
<p>创建数据处理线程</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE m_hThread  = CreateThread(NULL, <span class="number">0</span>, thread_work, this, <span class="number">0</span>, NULL);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开始处理数据</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">thread_work</span><span class="params">(LPVOID lpParmeter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    CMyClass * pThis = (CMyClass*)lpParmeter;</span><br><span class="line">    </span><br><span class="line">    DataInfo dataInfo;<span class="comment">//实例化缓存结构体</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当缓存队列中的数据大于0时，不断将数据取出进行处理</span></span><br><span class="line">    <span class="keyword">while</span>(pThis-&gt;m_dq_buf.size()&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      dataInfo = pThis-&gt;m_dq_buf.front();</span><br><span class="line">      CheckData(dataInfo);<span class="comment">//数据处理函数对数据进行处理或存储</span></span><br><span class="line">      <span class="keyword">delete</span> dataInfo.pBuf;<span class="comment">//数据处理完成释放内存</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">//使用临界区加锁</span></span><br><span class="line">      EnterCriticalSection(&amp;pThis-&gt;m_lock);<span class="comment">//进入临界区</span></span><br><span class="line">  </span><br><span class="line">      pThis-&gt;m_dq_buf.pop();<span class="comment">//将缓存从队列中删除</span></span><br><span class="line">  </span><br><span class="line">      LeaveCriticalSection(&amp;pThis-&gt;m_lock);<span class="comment">//退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>​       以上便是缓存队列的实现过程，需要注意的是，数据处理的速度一定要大于数据获取或采集的速度，否则缓存队列里的缓存将不断增大，从而造成内存泄露。</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
